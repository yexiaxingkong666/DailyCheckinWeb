type AnyFunction = (...args: any) => any;
type AsyncFunciton<T extends AnyFunction> = (...args: Parameters<T>) => Awaited<ReturnType<T>>;
type AnyAsyncFunction = AsyncFunciton<AnyFunction>;

declare const isSymobl: (v: unknown) => v is symbol;
declare const isString: (v: unknown) => v is string;
declare const isNumber: (v: unknown) => v is number;
declare const isBoolean: (v: unknown) => v is boolean;
declare const isArray: (v: unknown) => v is any[];
declare const isFunction: (v: unknown) => v is Function;
declare const isObject: (v: unknown) => v is object;
declare const isAsyncFunciton: (v: unknown) => v is AnyAsyncFunction;
declare const isSet: (v: unknown) => v is Set<any>;
declare const isWeakSet: (v: unknown) => v is WeakSet<any>;
declare const isMap: (v: unknown) => v is Map<any, any>;
declare const isWeakMap: (v: unknown) => v is WeakMap<any, any>;
declare const isPromise: (v: unknown) => v is Promise<any>;

type UnArray<T> = T extends Array<infer P> ? P : T;
type UnSet<T> = T extends Set<infer P> ? P : T;
type UnWeakSet<T> = T extends WeakSet<infer P> ? P : T;
type UnMap<T> = T extends Map<infer K, infer V> ? [K, V] : T;
type UnWeakMap<T> = T extends WeakMap<infer K, infer V> ? [K, V] : T;
type UnPromise<T> = T extends Promise<infer P> ? P : T;
type UnPromiseReturnType<T extends AnyFunction> = UnPromise<ReturnType<T>>;
type UnAsyncFunctionReturnType<T extends AnyAsyncFunction> = UnPromise<ReturnType<T>>;

type PartialPick<T, K extends keyof T> = Partial<Pick<T, K>>;
type RequiredPick<T, K extends keyof T> = Required<Pick<T, K>>;
type ReadonlyPick<T, K extends keyof T> = Readonly<Pick<T, K>>;

type ItemExist<V, A = []> = A extends [
    infer F,
    ...infer P
] ? V extends F ? V : ItemExist<V, P> : never;
type ItemNotExist<V, A = []> = A extends [
    infer F,
    ...infer P
] ? V extends F ? never : ItemNotExist<V, P> : V;
type FilterNeverInArray<T, G extends unknown[] = []> = T extends [infer F, ...infer P] ? FilterNeverInArray<P, [
    F
] extends [never] ? [...G] : [...G, F]> : G;
type UniqueArray<T, G extends unknown[] = []> = T extends [...infer P, infer L] ? UniqueArray<P, [ItemNotExist<L, P>, ...G]> : FilterNeverInArray<G>;

type PickUnion<U, K> = U extends K ? U : never;
type OmitUnion<U, K> = U extends PickUnion<U, K> ? never : U;
type UnionToIntersection<T> = (T extends any ? (args: T) => any : never) extends (args: infer R) => any ? R : never;
type LastInUnion<T> = UnionToIntersection<T extends any ? (arg: T) => any : never> extends (arg: infer R) => any ? R : never;
type UnionToTuple<T, U = T> = [T] extends [never] ? [] : [
    ...UnionToTuple<Exclude<U, LastInUnion<T>>>,
    LastInUnion<T>
];

type MayBeArray<T> = T | Array<T>;
type MayBePromise<T> = T | Promise<T>;

export { AnyAsyncFunction, AnyFunction, AsyncFunciton, FilterNeverInArray, ItemExist, ItemNotExist, LastInUnion, MayBeArray, MayBePromise, OmitUnion, PartialPick, PickUnion, ReadonlyPick, RequiredPick, UnArray, UnAsyncFunctionReturnType, UnMap, UnPromise, UnPromiseReturnType, UnSet, UnWeakMap, UnWeakSet, UnionToIntersection, UnionToTuple, UniqueArray, isArray, isAsyncFunciton, isBoolean, isFunction, isMap, isNumber, isObject, isPromise, isSet, isString, isSymobl, isWeakMap, isWeakSet };
