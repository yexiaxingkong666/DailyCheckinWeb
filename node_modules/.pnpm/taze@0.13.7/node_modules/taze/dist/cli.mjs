import process from 'node:process';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import c from 'picocolors';
import { run, parseNi, parseNu, getCommand } from '@antfu/ni';
import prompts from 'prompts';
import { MultiBar, Presets } from 'cli-progress';
import { g as getDiff, s as semver, e as DiffColorMap, f as DiffMap, D as DependenciesTypeShortMap, h as semver$1, u as updateTargetVersion, i as getVersionOfRange, j as getPrefixedVersion, C as CheckPackages, w as writePackage, c as loadPackages, k as getPackageData, _ as _debug, t as toArray, r as resolvePackage, m as createDependenciesFilter, d as dumpDependencies } from './shared/taze.c2ef066c.mjs';
import readline from 'node:readline';
import deepmerge from 'deepmerge';
import { createConfigLoader } from 'unconfig';
import { async } from '@jsdevtools/ez-spawn';
import 'node:path';
import 'node:fs';
import 'os';
import 'path';
import 'util';
import 'stream';
import 'events';
import 'fs';
import 'detect-indent';
import 'node:os';
import 'tty';
import 'ufo';

const pkgJson = {name:"taze",type:"module",version:"0.13.7",packageManager:"pnpm@9.0.6",description:"A modern cli tool that keeps your deps fresh",license:"MIT",funding:"https://github.com/sponsors/antfu",homepage:"https://github.com/antfu/taze#readme",repository:{type:"git",url:"git+https://github.com/antfu/taze.git"},bugs:{url:"https://github.com/antfu/taze/issues"},main:"dist/index.mjs",module:"dist/index.mjs",types:"dist/index.d.ts",bin:{taze:"bin/taze.mjs"},files:["dist"],scripts:{lint:"eslint .",dev:"cross-env DEBUG=taze:* esno ./src/cli.ts",start:"esno ./src/cli.ts",build:"unbuild",typecheck:"tsc",prepublishOnly:"nr build",release:"bumpp && pnpm publish --no-git-checks",test:"unbuild && vitest"},dependencies:{"@antfu/ni":"^0.21.12","@jsdevtools/ez-spawn":"^3.0.4","cli-progress":"^3.12.0",deepmerge:"^4.3.1","detect-indent":"^7.0.1",picocolors:"^1.0.0",prompts:"^2.4.2",ufo:"^1.5.3",unconfig:"^0.3.13",yargs:"^17.7.2"},devDependencies:{"@antfu/eslint-config":"^2.16.0","@antfu/utils":"^0.7.7","@npmcli/config":"^8.3.0","@types/cli-progress":"^3.11.5","@types/debug":"^4.1.12","@types/node":"^20.12.7","@types/npm-package-arg":"^6.1.4","@types/npm-registry-fetch":"^8.0.7","@types/prompts":"^2.4.9","@types/semver":"^7.5.8","@types/yargs":"^17.0.32",bumpp:"^9.4.0","cross-env":"^7.0.3",debug:"^4.3.4",eslint:"^9.1.1",esno:"^4.7.0","fast-glob":"^3.3.2","npm-package-arg":"^11.0.2","npm-registry-fetch":"^16.2.1",rimraf:"^5.0.5",semver:"^7.6.0",taze:"workspace:*",typescript:"^5.4.5",unbuild:"^2.0.0",vitest:"^1.5.2"}};

const LOG_LEVELS = ["debug", "info", "warn", "error", "silent"];
const MODE_CHOICES = ["default", "major", "minor", "patch", "latest", "newest"];
const DEFAULT_COMMON_OPTIONS = {
  cwd: "",
  loglevel: "info",
  failOnOutdated: false,
  silent: false,
  recursive: false,
  force: false,
  ignorePaths: "",
  include: "",
  exclude: "",
  depFields: {}
};
const DEFAULT_USAGE_OPTIONS = {
  ...DEFAULT_COMMON_OPTIONS,
  detail: false,
  recursive: true
};
const DEFAULT_CHECK_OPTIONS = {
  ...DEFAULT_COMMON_OPTIONS,
  mode: "default",
  write: false,
  global: false,
  // TODO: enable by default: !process.env.CI && process.stdout.isTTY,
  interactive: false,
  install: false,
  update: false,
  all: false,
  sort: "diff-asc",
  includeLocked: false
};

const FIG_CHECK = c.green("\u25C9");
const FIG_UNCHECK = c.gray("\u25CC");
const FIG_POINTER = c.cyan("\u276F ");
const FIG_NO_POINTER = "  ";
const FIG_BLOCK = c.bold(c.dim(c.gray("\u2503")));
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
const stripAnsi = (str) => typeof str === "string" ? str.replace(ansiRegex(), "") : str;
function visualLength(str) {
  if (str === "")
    return 0;
  str = stripAnsi(str);
  let width = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.codePointAt(i);
    if (!code)
      continue;
    if (code <= 31 || code >= 127 && code <= 159)
      continue;
    if (code >= 768 && code <= 879)
      continue;
    if (code > 65535)
      i++;
    width += 1;
  }
  return width;
}
function visualPadStart(str, pad, char = " ") {
  return str.padStart(pad - visualLength(str) + str.length, char);
}
function visualPadEnd(str, pad, char = " ") {
  return str.padEnd(pad - visualLength(str) + str.length, char);
}
function formatTable(lines, align, spaces = "  ") {
  const maxLen = [];
  lines.forEach((line) => {
    line.forEach((char, i) => {
      const len = visualLength(char);
      if (!maxLen[i] || maxLen[i] < len)
        maxLen[i] = len;
    });
  });
  return lines.map((line) => line.map((chars, i) => {
    const pad = align[i] === "R" ? visualPadStart : visualPadEnd;
    return pad(chars, maxLen[i]);
  }).join(spaces));
}
function colorizeVersionDiff(from, to, hightlightRange = true) {
  let leadingWildcard = "";
  let fromLeadingWildcard = "";
  if (/^[~^]/.test(to)) {
    leadingWildcard = to[0];
    to = to.slice(1);
  }
  if (/^[~^]/.test(from)) {
    fromLeadingWildcard = from[0];
    from = from.slice(1);
  }
  const partsToColor = to.split(".");
  const partsToCompare = from.split(".");
  let i = partsToColor.findIndex((part, i2) => part !== partsToCompare[i2]);
  i = i >= 0 ? i : partsToColor.length;
  let diffType = null;
  try {
    diffType = getDiff(new semver.SemVer(from), new semver.SemVer(to));
  } catch (error) {
  }
  const color = DiffColorMap[diffType || "patch"];
  const middot = i > 0 && i < partsToColor.length ? "." : "";
  const leadingColor = leadingWildcard === fromLeadingWildcard || !hightlightRange ? "gray" : "yellow";
  return c[leadingColor](leadingWildcard) + partsToColor.slice(0, i).join(".") + middot + c[color](partsToColor.slice(i).join(".")).trim();
}
function createSliceRender() {
  const buffer = [];
  return {
    push(...lines) {
      buffer.push(...lines);
    },
    render(selectedDepIndex) {
      let {
        rows: remainHeight,
        columns: availableWidth
      } = process.stdout;
      const lines = buffer.length < remainHeight - 1 ? buffer : [...buffer, { content: c.yellow("  -- END --") }];
      remainHeight -= 1;
      let i = 0;
      while (i < lines.length) {
        const curr = lines[i];
        if (curr.fixed) {
          console.log(curr.content);
          remainHeight -= 1;
          i++;
        } else {
          break;
        }
      }
      const remainLines = lines.slice(i);
      let focusedLineIndex = 0;
      let depIndex = 0;
      for (const line of remainLines) {
        if (line.content.includes(FIG_CHECK) || line.content.includes(FIG_UNCHECK))
          depIndex += 1;
        if (depIndex === selectedDepIndex)
          break;
        else
          focusedLineIndex += 1;
      }
      let slice;
      if (remainHeight < 1 || remainLines.length === 0 || remainLines.length <= remainHeight || lines.some((x) => Math.ceil(visualLength(x.content) / availableWidth) > 1)) {
        slice = remainLines;
      } else {
        const half = Math.floor((remainHeight - 1) / 2);
        const f = focusedLineIndex - half;
        const b = focusedLineIndex + remainHeight - half - remainLines.length;
        const start = Math.max(0, b <= 0 ? f : f - b);
        slice = remainLines.slice(start, start + remainHeight);
      }
      console.log(slice.map((x) => x.content).join("\n"));
    }
  };
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function shouldLog(level, messageLevel) {
  return LOG_LEVELS.indexOf(level) <= LOG_LEVELS.indexOf(messageLevel);
}
class TableLogger {
  constructor(options = {}) {
    __publicField(this, "options");
    __publicField(this, "rows", []);
    const {
      columns = 3,
      pending = 2,
      align = "",
      loglevel = "error"
    } = options;
    this.options = {
      columns,
      pending,
      align,
      loglevel
    };
  }
  row(...args) {
    this.rows.push(args);
  }
  log(string = "") {
    this.rows.push(string);
  }
  error(string = "") {
    if (shouldLog(this.options.loglevel, "error"))
      this.rows.push(string);
  }
  warn(string = "") {
    if (shouldLog(this.options.loglevel, "warn"))
      this.rows.push(string);
  }
  debug(string = "") {
    if (shouldLog(this.options.loglevel, "debug"))
      this.rows.push(string);
  }
  output() {
    if (this.options.loglevel === "silent")
      return;
    const { columns, align, pending } = this.options;
    const columnsWidth = Array.from({ length: columns }, () => 0);
    this.rows.forEach((line) => {
      if (typeof line === "string")
        return;
      for (let i = 0; i < columns; i++)
        columnsWidth[i] = Math.max(columnsWidth[i], visualLength(line[i] || ""));
    });
    this.rows.forEach((line) => {
      if (typeof line === "string") {
        process.stdout.write(`${line}
`);
        return;
      }
      for (let i = 0; i < columns; i++) {
        const pad = align[i] === "R" ? visualPadStart : visualPadEnd;
        const part = line[i] || "";
        process.stdout.write(pad(part, columnsWidth[i] + pending));
      }
      process.stdout.write("\n");
    });
    this.rows = [];
  }
}
function createMultiProgressBar() {
  return new MultiBar({
    clearOnComplete: true,
    hideCursor: true,
    format: `{type} {bar} {value}/{total} ${c.gray("{name}")}`,
    linewrap: false,
    barsize: 40
  }, Presets.shades_grey);
}
function wrapJoin(strs, delimiter, width) {
  const lines = [];
  let line = "";
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    if (line && visualLength(line + str) > width) {
      lines.push(line);
      line = "";
    }
    line += str;
    if (i < strs.length - 1)
      line += delimiter;
  }
  lines.push(line);
  return lines;
}

function notNullish(v) {
  return v != null;
}
function createControlledPromise() {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}

const msPerMinute = 60 * 1e3;
const msPerHour = msPerMinute * 60;
const msPerDay = msPerHour * 24;
const msPerMonth = msPerDay * 30;
const msPerYear = msPerDay * 365;
function toDate(date) {
  return +new Date(date);
}
function timeDifference(from, to = +/* @__PURE__ */ new Date()) {
  if (!from)
    return "";
  if (typeof from === "string")
    from = toDate(from);
  const elapsed = to - from;
  if (elapsed < msPerDay)
    return c.gray("\u2A7D1d");
  else if (elapsed < msPerMonth)
    return c.green(`~${Math.round(elapsed / msPerDay)}d`);
  else if (elapsed < msPerYear)
    return c.yellow(`~${Math.round(elapsed / msPerMonth)}mo`);
  else
    return c.red(`~${+(elapsed / msPerYear).toFixed(1)}y`);
}

const SORT_CHOICES = [
  "time-asc",
  "time-desc",
  "diff-asc",
  "diff-desc",
  "name-asc",
  "name-desc"
];
function parseSortOption(option) {
  return option.split("-");
}
function sortDepChanges(changes, option) {
  const [sortKey, order = "asc"] = parseSortOption(option);
  const sorted = changes.concat().sort((a, b) => {
    if (sortKey === "time") {
      if (a.targetVersionTime && b.targetVersionTime) {
        const at = toDate(a.targetVersionTime);
        const bt = toDate(b.targetVersionTime);
        return bt - at;
      }
    } else if (sortKey === "name") {
      return a.name.localeCompare(b.name);
    } else if (sortKey === "diff") {
      return DiffMap[a.diff || ""] - DiffMap[b.diff || ""];
    }
    return 0;
  });
  return order === "desc" ? sorted.reverse() : sorted;
}

function renderChange(change, interactive) {
  const update = change.update && (!interactive || change.interactiveChecked);
  const isSelected = interactive && interactive.isSelected(change);
  const pre = interactive ? [
    isSelected ? FIG_POINTER : FIG_NO_POINTER,
    change.interactiveChecked ? FIG_CHECK : FIG_UNCHECK
  ].join("") : " ";
  let name = change.name;
  if (change.aliasName)
    name = c.dim(`${change.aliasName} \u2190 `) + change.name;
  return [
    `${pre} ${update ? name : c.gray(name)}`,
    c.gray(DependenciesTypeShortMap[change.source]),
    timeDifference(change.currentVersionTime),
    c.gray(change.currentVersion),
    update ? c.dim(c.gray("\u2192")) : "",
    update ? colorizeVersionDiff(change.currentVersion, change.targetVersion) : c.gray(c.strikethrough(change.targetVersion)),
    update ? timeDifference(change.targetVersionTime) : "",
    change.latestVersionAvailable && semver$1.minVersion(change.targetVersion).toString() !== change.latestVersionAvailable ? c.dim(c.magenta(`(${change.latestVersionAvailable} available)`)) : ""
  ];
}
function renderChanges(pkg, options, interactive) {
  const { resolved, relative: filepath } = pkg;
  const lines = [];
  const errLines = [];
  let changes = options.all ? resolved : resolved.filter((i) => i.update);
  const {
    sort = "diff-asc"
  } = options;
  if (changes.length) {
    const diffCounts = {};
    changes.filter((i) => !interactive || i.interactiveChecked).forEach(({ diff }) => {
      if (!diff)
        return;
      if (!diffCounts[diff])
        diffCounts[diff] = 0;
      diffCounts[diff] += 1;
    });
    changes = sortDepChanges(changes, sort);
    const diffEntries = Object.keys(diffCounts).length ? Object.entries(diffCounts).map(([key, value]) => `${c[DiffColorMap[key || "patch"]](value)} ${key}`).join(", ") : c.dim("no change");
    lines.push(
      // c.dim(c.gray(filepath)),
      `${c.cyan(pkg.name ?? "\u203A")} ${c.dim("-")} ${diffEntries}`,
      ""
    );
    lines.push(...formatTable(
      changes.map((c2) => renderChange(c2, interactive)),
      "LLRRRRRL"
    ));
    lines.push("");
  } else if (options.all) {
    lines.push(`${c.cyan(pkg.name)} ${c.dim(filepath)}`);
    lines.push();
    lines.push(c.gray("  \u2713 up to date"));
  }
  const errors = pkg.resolved.filter((i) => i.resolveError != null);
  if (errors.length) {
    lines.push();
    for (const dep of errors)
      errLines.push(...renderResolveError(dep));
    lines.push();
  }
  return {
    lines,
    errLines
  };
}
function renderResolveError(dep) {
  const lines = [];
  if (dep.resolveError == null)
    return lines;
  if (dep.resolveError === "404") {
    lines.push(c.red(`> ${c.underline(dep.name)} not found`));
  } else if (dep.resolveError === "invalid_range") ; else {
    lines.push(c.red(`> ${c.underline(dep.name)} unknown error`));
    lines.push(c.red(dep.resolveError.toString()));
  }
  return lines;
}
function outputErr(errLines) {
  console.error(c.inverse(c.red(c.bold(" ERROR "))));
  console.error();
  console.error(errLines.join("\n"));
  console.error();
}
function renderPackages(resolvePkgs, options) {
  const lines = [""];
  const errLines = [];
  resolvePkgs.forEach((pkg) => {
    const result = renderChanges(pkg, options);
    lines.push(...result.lines);
    errLines.push(...result.errLines);
  });
  return { lines, errLines };
}

async function promptInteractive(pkgs, options) {
  const {
    sort = "diff-asc"
  } = options;
  pkgs.forEach((i) => {
    i.interactiveChecked = true;
    i.resolved.forEach((i2) => {
      i2.interactiveChecked = i2.update;
      if (i2.latestVersionAvailable && !i2.update) {
        i2.interactiveChecked = false;
        i2.update = true;
        updateTargetVersion(i2, i2.latestVersionAvailable, void 0, options.includeLocked);
      }
    });
    i.resolved = sortDepChanges(i.resolved, sort);
  });
  if (!pkgs.some((i) => i.resolved.some((i2) => i2.update)))
    return [];
  const promise = createControlledPromise();
  const listRenderer = createListRenderer();
  let renderer = listRenderer;
  registerInput();
  renderer.render();
  return await promise.finally(() => {
    renderer = {
      render: () => {
      },
      onKey: () => false
    };
  });
  function createListRenderer() {
    const deps = pkgs.flatMap((i) => i.resolved.filter((i2) => i2.update));
    let index = 0;
    const ctx = {
      isSelected(dep) {
        return dep === deps[index];
      }
    };
    return {
      render() {
        const sr = createSliceRender();
        const Y = (v) => c.bold(c.green(v));
        console.clear();
        sr.push({ content: `${FIG_BLOCK} ${c.gray(`${Y("\u2191\u2193")} to select, ${Y("space")} to toggle, ${Y("\u2192")} to change version`)}`, fixed: true });
        sr.push({ content: `${FIG_BLOCK} ${c.gray(`${Y("enter")} to confirm, ${Y("esc")} to cancel, ${Y("a")} to select/unselect all`)}`, fixed: true });
        sr.push({ content: "", fixed: true });
        pkgs.forEach((pkg) => {
          sr.push(...renderChanges(pkg, options, ctx).lines.map((x) => ({ content: x })));
        });
        sr.render(index);
      },
      onKey(key) {
        const allInteractiveChecked = deps.every((d) => d.interactiveChecked);
        switch (key.name) {
          case "escape":
            process.exit();
          case "enter":
          case "return":
            console.clear();
            pkgs.forEach((i) => {
              i.resolved.forEach((i2) => {
                i2.update = !!i2.interactiveChecked;
              });
            });
            promise.resolve(pkgs);
            break;
          case "up":
          case "k":
            index = (index - 1 + deps.length) % deps.length;
            return true;
          case "down":
          case "j":
            index = (index + 1) % deps.length;
            return true;
          case "space":
            deps[index].interactiveChecked = !deps[index].interactiveChecked;
            return true;
          case "right":
          case "l":
            renderer = createVersionSelectRender(deps[index]);
            return true;
          case "a":
            deps.forEach((d) => d.interactiveChecked = !allInteractiveChecked);
            return true;
        }
      }
    };
  }
  function createVersionSelectRender(dep) {
    const versions = Object.entries({
      minor: getVersionOfRange(dep, "minor"),
      patch: getVersionOfRange(dep, "patch"),
      ...dep.pkgData.tags
    }).map(([name, version]) => {
      if (!version)
        return void 0;
      const targetVersion = getPrefixedVersion(dep.currentVersion, version);
      if (!targetVersion || targetVersion === dep.currentVersion)
        return void 0;
      return {
        name,
        version,
        time: dep.pkgData.time?.[version],
        targetVersion: getPrefixedVersion(dep.currentVersion, version)
      };
    }).filter(notNullish);
    let index = 0;
    return {
      render() {
        console.clear();
        console.log(`${FIG_BLOCK} ${c.gray(`Select a version for ${c.green(c.bold(dep.name))}${c.gray(` (current ${dep.currentVersion})`)}`)}`);
        console.log();
        console.log(
          formatTable(versions.map((v, idx) => {
            return [
              (index === idx ? FIG_POINTER : FIG_NO_POINTER) + (index === idx ? v.name : c.gray(v.name)),
              timeDifference(dep.currentVersionTime),
              c.gray(dep.currentVersion),
              c.dim(c.gray("\u2192")),
              colorizeVersionDiff(dep.currentVersion, v.targetVersion),
              timeDifference(v.time)
            ];
          }), "LLLL").join("\n")
        );
      },
      onKey(key) {
        switch (key.name) {
          case "escape":
            renderer = listRenderer;
            return true;
          case "up":
          case "k":
            index = (index - 1 + versions.length) % versions.length;
            return true;
          case "down":
          case "j":
            index = (index + 1) % versions.length;
            return true;
          case "enter":
          case "return":
          case "left":
          case "right":
          case "h":
          case "l":
            updateTargetVersion(dep, versions[index].version, void 0, options.includeLocked);
            renderer = listRenderer;
            return true;
        }
      }
    };
  }
  function registerInput() {
    process.stdin.resume();
    process.stdin.setEncoding("utf8");
    readline.emitKeypressEvents(process.stdin);
    if (process.stdin.isTTY)
      process.stdin.setRawMode(true);
    process.stdin.on("keypress", (str, key) => {
      if (key.ctrl && key.name === "c")
        process.exit();
      const result = renderer.onKey(key);
      if (result && typeof result !== "boolean")
        renderer = result;
      if (result)
        renderer.render();
    });
  }
}

async function check(options) {
  let exitCode = 0;
  const bars = options.loglevel === "silent" ? null : createMultiProgressBar();
  let packagesBar;
  const depBar = bars?.create(1, 0);
  let resolvePkgs = [];
  await CheckPackages(options, {
    afterPackagesLoaded(pkgs) {
      packagesBar = options.recursive && pkgs.length ? bars?.create(pkgs.length, 0, { type: c.cyan("pkg"), name: c.cyan(pkgs[0].name) }) : void 0;
    },
    beforePackageStart(pkg) {
      packagesBar?.increment(0, { name: c.cyan(pkg.name) });
      depBar?.start(pkg.deps.length, 0, { type: c.green("dep"), name: "" });
    },
    beforePackageWrite() {
      return false;
    },
    afterPackageEnd(pkg) {
      packagesBar?.increment(1);
      depBar?.stop();
      resolvePkgs.push(pkg);
    },
    onDependencyResolved(pkgName, name, progress) {
      depBar?.update(progress, { name });
    }
  });
  bars?.stop();
  if (options.interactive)
    resolvePkgs = await promptInteractive(resolvePkgs, options);
  const { lines, errLines } = renderPackages(resolvePkgs, options);
  const hasChanges = resolvePkgs.length && resolvePkgs.some((i) => i.resolved.some((j) => j.update));
  if (!hasChanges) {
    if (errLines.length)
      outputErr(errLines);
    else
      console.log(c.green("dependencies are already up-to-date"));
    return exitCode;
  }
  console.log(lines.join("\n"));
  if (!options.all) {
    const counter = resolvePkgs.reduce((counter2, pkg) => {
      for (let i = 0; i < pkg.resolved.length; i++) {
        if (pkg.resolved[i].update)
          return ++counter2;
      }
      return counter2;
    }, 0);
    const last = resolvePkgs.length - counter;
    if (last === 1)
      console.log(c.green("dependencies are already up-to-date in one package\n"));
    else if (last > 0)
      console.log(c.green(`dependencies are already up-to-date in ${last} packages
`));
  }
  if (errLines.length)
    outputErr(errLines);
  if (options.interactive && !options.write) {
    options.write = await prompts([
      {
        name: "write",
        type: "confirm",
        initial: true,
        message: c.green("write to package.json")
      }
    ]).then((r) => r.write);
  }
  if (options.write) {
    for (const pkg of resolvePkgs)
      await writePackage(pkg, options);
  }
  if (!options.write) {
    console.log();
    if (options.mode === "default")
      console.log(`Run ${c.cyan("taze major")} to check major updates`);
    if (hasChanges) {
      if (options.failOnOutdated)
        exitCode = 1;
      console.log(`Add ${c.green("-w")} to write to package.json`);
    }
    console.log();
  } else if (hasChanges) {
    if (!options.install && !options.update && !options.interactive) {
      console.log(
        c.yellow(`\u2139 changes written to package.json, run ${c.cyan("npm i")} to install updates.`)
      );
    }
    if (options.install || options.update || options.interactive)
      console.log(c.yellow("\u2139 changes written to package.json"));
    if (options.interactive && !options.install) {
      options.install = await prompts([
        {
          name: "install",
          type: "confirm",
          initial: true,
          message: c.green("install now")
        }
      ]).then((r) => r.install);
    }
    if (options.install) {
      console.log(c.magenta("installing..."));
      console.log();
      await run(parseNi, []);
    }
    if (options.update) {
      console.log(c.magenta("updating..."));
      console.log();
      await run(parseNu, options.recursive ? ["-r"] : []);
    }
  }
  return exitCode;
}

async function CheckUsages(options, callbacks = {}) {
  const packages = await loadPackages(options);
  const names = {};
  for (const pkg of packages) {
    for (const dep of pkg.deps) {
      if (!names[dep.name])
        names[dep.name] = {};
      if (!names[dep.name][dep.currentVersion])
        names[dep.name][dep.currentVersion] = [];
      names[dep.name][dep.currentVersion].push(pkg);
    }
  }
  const usages = Object.entries(names).filter((i) => Object.keys(i[1]).length > 1).sort((a, b) => Object.keys(b[1]).length - Object.keys(a[1]).length).map(([name, versionMap]) => ({ name, versionMap }));
  callbacks.onLoaded?.(usages);
  let progress = 0;
  const total = usages.length;
  const resolveUsages = await Promise.all(
    usages.map(async ({ name, versionMap }) => {
      const { tags } = await getPackageData(name);
      progress += 1;
      callbacks.onDependencyResolved?.(null, name, progress, total);
      return { name, versionMap, latest: tags.latest || "" };
    })
  );
  return resolveUsages;
}

async function usage(options) {
  const bars = createMultiProgressBar();
  const logger = new TableLogger({
    columns: 5,
    align: "LRRRR",
    loglevel: options.loglevel
  });
  logger.log();
  let depBar;
  const resolveUsages = await CheckUsages(options, {
    onLoaded(usages) {
      depBar = bars.create(usages.length, 0, { type: c.green("deps") });
    },
    onDependencyResolved(_, name) {
      depBar?.increment(1, { name });
    }
  });
  bars.stop();
  for (const { name, versionMap, latest } of resolveUsages) {
    const versions = Object.keys(versionMap).sort();
    const packagesCount = Object.values(versionMap).flatMap((i) => i).length;
    if (versions.length > 1) {
      const color = versions.length >= 5 ? "magenta" : versions.length >= 3 ? "red" : "yellow";
      if (options.detail) {
        logger.log();
        logger.row(
          `${c.green(name)} ${c.gray(`\xB7 ${versions.length} versions \xB7 latest: ${c.blue(latest)}`)}`
        );
        const pad = Math.max(8, ...Object.keys(versionMap).map((i) => i.length)) + 2;
        for (const [version, pkgs] of Object.entries(versionMap)) {
          const lines = wrapJoin(pkgs.map((p) => p.name), c.gray(", "), 80);
          lines.forEach((line, i) => {
            if (i === 0)
              logger.log(`${visualPadStart(c.gray(colorizeVersionDiff(latest || version, version, false)), pad, " ")}  ${line}`);
            else
              logger.log(`${" ".padStart(pad, " ")}  ${line}`);
          });
        }
      } else {
        logger.row(
          c.green(name),
          c.gray(`${c.cyan(packagesCount.toString())} in use / ${c[color](versions.length.toString())} versions`),
          versions.map((v) => c.gray(colorizeVersionDiff(latest || v, v, false))).join(c.gray(", ")),
          c.gray("\u2192"),
          latest
        );
      }
    }
  }
  logger.log();
  logger.output();
}

const debug = _debug("taze:config");
function normalizeConfig(options) {
  options.ignorePaths = toArray(options.ignorePaths);
  options.exclude = toArray(options.exclude);
  options.include = toArray(options.include);
  if (options.silent)
    options.loglevel = "silent";
  return options;
}
async function resolveConfig(options) {
  const defaults = options?._?.[0] === "usage" ? DEFAULT_USAGE_OPTIONS : DEFAULT_CHECK_OPTIONS;
  options = normalizeConfig(options);
  const loader = createConfigLoader({
    sources: [
      {
        files: [
          "taze.config"
        ]
      },
      {
        files: [
          ".tazerc"
        ],
        extensions: ["json", ""]
      }
    ],
    cwd: options.cwd || process.cwd(),
    merge: false
  });
  const config = await loader.load();
  if (!config.sources.length)
    return deepmerge(defaults, options);
  debug(`config file found ${config.sources[0]}`);
  const configOptions = normalizeConfig(config.config);
  return deepmerge(deepmerge(defaults, configOptions), options);
}

async function checkGlobal(options) {
  let exitCode = 0;
  let resolvePkgs = [];
  const globalPkgs = await Promise.all([
    loadGlobalNpmPackage(options),
    loadGlobalPnpmPackage(options)
  ]);
  const pkgs = globalPkgs.flat(1);
  const bars = options.loglevel === "silent" ? null : createMultiProgressBar();
  await Promise.all(pkgs.map(async (pkg) => {
    const depBar = bars?.create(pkg.deps.length, 0, { type: c.green(pkg.agent) });
    await resolvePackage(
      pkg,
      options,
      () => true,
      (_pkgName, name, progress) => depBar?.update(progress, { name })
    );
  }));
  bars?.stop();
  resolvePkgs = pkgs;
  if (options.interactive)
    resolvePkgs = await promptInteractive(resolvePkgs, options);
  const { lines, errLines } = renderPackages(resolvePkgs, options);
  const hasChanges = resolvePkgs.length && resolvePkgs.some((i) => i.resolved.some((j) => j.update));
  if (!hasChanges) {
    if (errLines.length)
      outputErr(errLines);
    else
      console.log(c.green("dependencies are already up-to-date"));
    return exitCode;
  }
  console.log(lines.join("\n"));
  if (errLines.length)
    outputErr(errLines);
  if (options.interactive && !options.install) {
    options.install = await prompts([
      {
        name: "install",
        type: "confirm",
        initial: true,
        message: c.green("install now")
      }
    ]).then((r) => r.install);
  }
  if (!options.write) {
    console.log();
    if (options.mode === "default")
      console.log(`Add ${c.green("major")} to check major updates`);
    if (hasChanges) {
      if (options.failOnOutdated)
        exitCode = 1;
      console.log(`Add ${c.green("-i")} to update global dependency`);
    }
    console.log();
  }
  if (options.install) {
    console.log(c.magenta("installing..."));
    console.log();
    for (const pkg of resolvePkgs)
      await installPkg(pkg);
  }
  return exitCode;
}
async function loadGlobalPnpmPackage(options) {
  let pnpmStdout;
  try {
    pnpmStdout = (await async("pnpm", ["ls", "--global", "--depth=0", "--json"], { stdio: "pipe" })).stdout;
  } catch (error) {
    return [];
  }
  const pnpmOuts = JSON.parse(pnpmStdout).filter((it) => it.dependencies != null);
  const filter = createDependenciesFilter(options.include, options.exclude);
  const pkgMetas = pnpmOuts.map(
    (pnpmOut) => Object.entries(pnpmOut.dependencies).filter(([_name, i]) => i?.version).map(([name, i]) => ({
      name,
      currentVersion: `^${i.version}`,
      update: filter(name),
      source: "dependencies"
    }))
  ).map((deps, i) => ({
    agent: "pnpm",
    resolved: [],
    raw: null,
    version: "",
    filepath: "",
    relative: "",
    deps,
    name: c.red("pnpm") + c.gray(c.dim(" (global)")) + c.gray(c.dim(` ${pnpmOuts[i].path}`))
  }));
  return pkgMetas;
}
async function loadGlobalNpmPackage(options) {
  const { stdout } = await async("npm", ["ls", "--global", "--depth=0", "--json"], { stdio: "pipe" });
  const npmOut = JSON.parse(stdout);
  const filter = createDependenciesFilter(options.include, options.exclude);
  const deps = Object.entries(npmOut.dependencies).filter(([_name, i]) => i?.version).map(([name, i]) => ({
    name,
    currentVersion: `^${i.version}`,
    update: filter(name),
    source: "dependencies"
  }));
  return {
    agent: "npm",
    resolved: [],
    raw: null,
    version: "",
    filepath: "",
    relative: "",
    deps,
    name: c.red("npm") + c.gray(c.dim(" (global)"))
  };
}
async function installPkg(pkg) {
  const changes = pkg.resolved.filter((i) => i.update);
  const dependencies = dumpDependencies(changes, "dependencies");
  const updateArgs = Object.entries(dependencies).map(([name, version]) => `${name}@${version}`);
  const installCommand = getCommand(pkg.agent, "global", [...updateArgs]);
  await async(installCommand, { stdio: "inherit" });
}

function commonOptions(args) {
  return args.option("cwd", {
    alias: "C",
    type: "string",
    describe: "specify the current working directory"
  }).option("loglevel", {
    type: "string",
    describe: "log level",
    choices: LOG_LEVELS
  }).option("failOnOutdated", {
    type: "boolean",
    describe: "exit with code 1 if outdated dependencies are found"
  }).option("silent", {
    alias: "s",
    type: "boolean",
    describe: "complete silent"
  }).option("recursive", {
    alias: "r",
    type: "boolean",
    describe: "recursively search for package.json in subdirectories"
  }).option("force", {
    alias: "f",
    type: "boolean",
    describe: "force fetching from server, bypass cache"
  }).option("ignore-paths", {
    type: "string",
    describe: "ignore paths for search package.json"
  }).option("include", {
    alias: "n",
    type: "string",
    describe: "only included dependencies will be checked for updates"
  }).option("exclude", {
    alias: "x",
    type: "string",
    describe: "exclude dependencies to be checked, will override --include options"
  });
}
yargs(hideBin(process.argv)).scriptName("taze").usage("$0 [args]").command(
  "usage",
  "List dependencies versions usage across packages",
  (args) => {
    return commonOptions(args).option("detail", {
      alias: "a",
      type: "boolean",
      describe: "show more info"
    }).help().demandOption("recursive", c.yellow("Please add -r to analysis usages"));
  },
  async (args) => usage(await resolveConfig({ ...args, recursive: true }))
).command(
  "* [mode]",
  "Keeps your deps fresh",
  (args) => {
    return commonOptions(args).positional("mode", {
      type: "string",
      describe: 'the mode how version range resolves, can be "default", "major", "minor", "latest" or "newest"',
      choices: MODE_CHOICES
    }).option("write", {
      alias: "w",
      type: "boolean",
      describe: "write to package.json"
    }).option("global", {
      alias: "g",
      type: "boolean",
      describe: "update global packages"
    }).option("interactive", {
      alias: "I",
      type: "boolean",
      describe: "interactive mode"
    }).option("install", {
      alias: "i",
      type: "boolean",
      describe: "install directly after bumping"
    }).option("update", {
      alias: "u",
      type: "boolean",
      describe: "update directly after bumping"
    }).option("all", {
      alias: "a",
      type: "boolean",
      describe: "show all packages up to date info"
    }).option("sort", {
      type: "string",
      choices: SORT_CHOICES,
      describe: "sort by most outdated absolute or relative to dependency"
    }).option("includeLocked", {
      alias: "l",
      type: "boolean",
      describe: "include locked dependencies & devDependencies"
    }).help();
  },
  async (args) => {
    let exitCode;
    if (args.global)
      exitCode = await checkGlobal(await resolveConfig(args));
    else
      exitCode = await check(await resolveConfig(args));
    process.exit(exitCode);
  }
).showHelpOnFail(false).alias("h", "help").version("version", pkgJson.version).alias("v", "version").help().argv;
