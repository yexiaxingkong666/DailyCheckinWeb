import { s as semver$2, n as getDefaultExportFromCjs, o as commonjsGlobal } from '../shared/taze.c2ef066c.mjs';
import require$$0 from 'url';
import { c as commonjs } from '../shared/taze.06f761a4.mjs';
import require$$0$1 from 'path';
import require$$0$2 from 'os';

var npa$3 = {exports: {}};

/* eslint-disable max-len */

const maybeJoin = (...args) => args.every(arg => arg) ? args.join('') : '';
const maybeEncode = (arg) => arg ? encodeURIComponent(arg) : '';
const formatHashFragment = (f) => f.toLowerCase().replace(/^\W+|\/|\W+$/g, '').replace(/\W+/g, '-');

const defaults = {
  sshtemplate: ({ domain, user, project, committish }) =>
    `git@${domain}:${user}/${project}.git${maybeJoin('#', committish)}`,
  sshurltemplate: ({ domain, user, project, committish }) =>
    `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
  edittemplate: ({ domain, user, project, committish, editpath, path }) =>
    `https://${domain}/${user}/${project}${maybeJoin('/', editpath, '/', maybeEncode(committish || 'HEAD'), '/', path)}`,
  browsetemplate: ({ domain, user, project, committish, treepath }) =>
    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}`,
  browsetreetemplate: ({ domain, user, project, committish, treepath, path, fragment, hashformat }) =>
    `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
  browseblobtemplate: ({ domain, user, project, committish, blobpath, path, fragment, hashformat }) =>
    `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || 'HEAD')}/${path}${maybeJoin('#', hashformat(fragment || ''))}`,
  docstemplate: ({ domain, user, project, treepath, committish }) =>
    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish))}#readme`,
  httpstemplate: ({ auth, domain, user, project, committish }) =>
    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
  filetemplate: ({ domain, user, project, committish, path }) =>
    `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || 'HEAD')}/${path}`,
  shortcuttemplate: ({ type, user, project, committish }) =>
    `${type}:${user}/${project}${maybeJoin('#', committish)}`,
  pathtemplate: ({ user, project, committish }) =>
    `${user}/${project}${maybeJoin('#', committish)}`,
  bugstemplate: ({ domain, user, project }) =>
    `https://${domain}/${user}/${project}/issues`,
  hashformat: formatHashFragment,
};

const hosts$1 = {};
hosts$1.github = {
  // First two are insecure and generally shouldn't be used any more, but
  // they are still supported.
  protocols: ['git:', 'http:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
  domain: 'github.com',
  treepath: 'tree',
  blobpath: 'blob',
  editpath: 'edit',
  filetemplate: ({ auth, user, project, committish, path }) =>
    `https://${maybeJoin(auth, '@')}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || 'HEAD')}/${path}`,
  gittemplate: ({ auth, domain, user, project, committish }) =>
    `git://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
  tarballtemplate: ({ domain, user, project, committish }) =>
    `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
  extract: (url) => {
    let [, user, project, type, committish] = url.pathname.split('/', 5);
    if (type && type !== 'tree') {
      return
    }

    if (!type) {
      committish = url.hash.slice(1);
    }

    if (project && project.endsWith('.git')) {
      project = project.slice(0, -4);
    }

    if (!user || !project) {
      return
    }

    return { user, project, committish }
  },
};

hosts$1.bitbucket = {
  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
  domain: 'bitbucket.org',
  treepath: 'src',
  blobpath: 'src',
  editpath: '?mode=edit',
  edittemplate: ({ domain, user, project, committish, treepath, path, editpath }) =>
    `https://${domain}/${user}/${project}${maybeJoin('/', treepath, '/', maybeEncode(committish || 'HEAD'), '/', path, editpath)}`,
  tarballtemplate: ({ domain, user, project, committish }) =>
    `https://${domain}/${user}/${project}/get/${maybeEncode(committish || 'HEAD')}.tar.gz`,
  extract: (url) => {
    let [, user, project, aux] = url.pathname.split('/', 4);
    if (['get'].includes(aux)) {
      return
    }

    if (project && project.endsWith('.git')) {
      project = project.slice(0, -4);
    }

    if (!user || !project) {
      return
    }

    return { user, project, committish: url.hash.slice(1) }
  },
};

hosts$1.gitlab = {
  protocols: ['git+ssh:', 'git+https:', 'ssh:', 'https:'],
  domain: 'gitlab.com',
  treepath: 'tree',
  blobpath: 'tree',
  editpath: '-/edit',
  httpstemplate: ({ auth, domain, user, project, committish }) =>
    `git+https://${maybeJoin(auth, '@')}${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
  tarballtemplate: ({ domain, user, project, committish }) =>
    `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || 'HEAD')}`,
  extract: (url) => {
    const path = url.pathname.slice(1);
    if (path.includes('/-/') || path.includes('/archive.tar.gz')) {
      return
    }

    const segments = path.split('/');
    let project = segments.pop();
    if (project.endsWith('.git')) {
      project = project.slice(0, -4);
    }

    const user = segments.join('/');
    if (!user || !project) {
      return
    }

    return { user, project, committish: url.hash.slice(1) }
  },
};

hosts$1.gist = {
  protocols: ['git:', 'git+ssh:', 'git+https:', 'ssh:', 'https:'],
  domain: 'gist.github.com',
  editpath: 'edit',
  sshtemplate: ({ domain, project, committish }) =>
    `git@${domain}:${project}.git${maybeJoin('#', committish)}`,
  sshurltemplate: ({ domain, project, committish }) =>
    `git+ssh://git@${domain}/${project}.git${maybeJoin('#', committish)}`,
  edittemplate: ({ domain, user, project, committish, editpath }) =>
    `https://${domain}/${user}/${project}${maybeJoin('/', maybeEncode(committish))}/${editpath}`,
  browsetemplate: ({ domain, project, committish }) =>
    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
  browsetreetemplate: ({ domain, project, committish, path, hashformat }) =>
    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
  browseblobtemplate: ({ domain, project, committish, path, hashformat }) =>
    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}${maybeJoin('#', hashformat(path))}`,
  docstemplate: ({ domain, project, committish }) =>
    `https://${domain}/${project}${maybeJoin('/', maybeEncode(committish))}`,
  httpstemplate: ({ domain, project, committish }) =>
    `git+https://${domain}/${project}.git${maybeJoin('#', committish)}`,
  filetemplate: ({ user, project, committish, path }) =>
    `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin('/', maybeEncode(committish))}/${path}`,
  shortcuttemplate: ({ type, project, committish }) =>
    `${type}:${project}${maybeJoin('#', committish)}`,
  pathtemplate: ({ project, committish }) =>
    `${project}${maybeJoin('#', committish)}`,
  bugstemplate: ({ domain, project }) =>
    `https://${domain}/${project}`,
  gittemplate: ({ domain, project, committish }) =>
    `git://${domain}/${project}.git${maybeJoin('#', committish)}`,
  tarballtemplate: ({ project, committish }) =>
    `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || 'HEAD')}`,
  extract: (url) => {
    let [, user, project, aux] = url.pathname.split('/', 4);
    if (aux === 'raw') {
      return
    }

    if (!project) {
      if (!user) {
        return
      }

      project = user;
      user = null;
    }

    if (project.endsWith('.git')) {
      project = project.slice(0, -4);
    }

    return { user, project, committish: url.hash.slice(1) }
  },
  hashformat: function (fragment) {
    return fragment && 'file-' + formatHashFragment(fragment)
  },
};

hosts$1.sourcehut = {
  protocols: ['git+ssh:', 'https:'],
  domain: 'git.sr.ht',
  treepath: 'tree',
  blobpath: 'tree',
  filetemplate: ({ domain, user, project, committish, path }) =>
    `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || 'HEAD'}/${path}`,
  httpstemplate: ({ domain, user, project, committish }) =>
    `https://${domain}/${user}/${project}.git${maybeJoin('#', committish)}`,
  tarballtemplate: ({ domain, user, project, committish }) =>
    `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || 'HEAD'}.tar.gz`,
  bugstemplate: ({ user, project }) => null,
  extract: (url) => {
    let [, user, project, aux] = url.pathname.split('/', 4);

    // tarball url
    if (['archive'].includes(aux)) {
      return
    }

    if (project && project.endsWith('.git')) {
      project = project.slice(0, -4);
    }

    if (!user || !project) {
      return
    }

    return { user, project, committish: url.hash.slice(1) }
  },
};

for (const [name, host] of Object.entries(hosts$1)) {
  hosts$1[name] = Object.assign({}, defaults, host);
}

var hosts_1 = hosts$1;

const url = require$$0;

const lastIndexOfBefore = (str, char, beforeChar) => {
  const startPosition = str.indexOf(beforeChar);
  return str.lastIndexOf(char, startPosition > -1 ? startPosition : Infinity)
};

const safeUrl = (u) => {
  try {
    return new url.URL(u)
  } catch {
    // this fn should never throw
  }
};

// accepts input like git:github.com:user/repo and inserts the // after the first :
const correctProtocol = (arg, protocols) => {
  const firstColon = arg.indexOf(':');
  const proto = arg.slice(0, firstColon + 1);
  if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
    return arg
  }

  const firstAt = arg.indexOf('@');
  if (firstAt > -1) {
    if (firstAt > firstColon) {
      return `git+ssh://${arg}`
    } else {
      return arg
    }
  }

  const doubleSlash = arg.indexOf('//');
  if (doubleSlash === firstColon + 1) {
    return arg
  }

  return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`
};

// attempt to correct an scp style url so that it will parse with `new URL()`
const correctUrl = (giturl) => {
  // ignore @ that come after the first hash since the denotes the start
  // of a committish which can contain @ characters
  const firstAt = lastIndexOfBefore(giturl, '@', '#');
  // ignore colons that come after the hash since that could include colons such as:
  // git@github.com:user/package-2#semver:^1.0.0
  const lastColonBeforeHash = lastIndexOfBefore(giturl, ':', '#');

  if (lastColonBeforeHash > firstAt) {
    // the last : comes after the first @ (or there is no @)
    // like it would in:
    // proto://hostname.com:user/repo
    // username@hostname.com:user/repo
    // :password@hostname.com:user/repo
    // username:password@hostname.com:user/repo
    // proto://username@hostname.com:user/repo
    // proto://:password@hostname.com:user/repo
    // proto://username:password@hostname.com:user/repo
    // then we replace the last : with a / to create a valid path
    giturl = giturl.slice(0, lastColonBeforeHash) + '/' + giturl.slice(lastColonBeforeHash + 1);
  }

  if (lastIndexOfBefore(giturl, ':', '#') === -1 && giturl.indexOf('//') === -1) {
    // we have no : at all
    // as it would be in:
    // username@hostname.com/user/repo
    // then we prepend a protocol
    giturl = `git+ssh://${giturl}`;
  }

  return giturl
};

var parseUrl$2 = (giturl, protocols) => {
  const withProtocol = protocols ? correctProtocol(giturl, protocols) : giturl;
  return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol))
};

const parseUrl$1 = parseUrl$2;

// look for github shorthand inputs, such as npm/cli
const isGitHubShorthand = (arg) => {
  // it cannot contain whitespace before the first #
  // it cannot start with a / because that's probably an absolute file path
  // but it must include a slash since repos are username/repository
  // it cannot start with a . because that's probably a relative file path
  // it cannot start with an @ because that's a scoped package if it passes the other tests
  // it cannot contain a : before a # because that tells us that there's a protocol
  // a second / may not exist before a #
  const firstHash = arg.indexOf('#');
  const firstSlash = arg.indexOf('/');
  const secondSlash = arg.indexOf('/', firstSlash + 1);
  const firstColon = arg.indexOf(':');
  const firstSpace = /\s/.exec(arg);
  const firstAt = arg.indexOf('@');

  const spaceOnlyAfterHash = !firstSpace || (firstHash > -1 && firstSpace.index > firstHash);
  const atOnlyAfterHash = firstAt === -1 || (firstHash > -1 && firstAt > firstHash);
  const colonOnlyAfterHash = firstColon === -1 || (firstHash > -1 && firstColon > firstHash);
  const secondSlashOnlyAfterHash = secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash);
  const hasSlash = firstSlash > 0;
  // if a # is found, what we really want to know is that the character
  // immediately before # is not a /
  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');
  const doesNotStartWithDot = !arg.startsWith('.');

  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash &&
    doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash &&
    secondSlashOnlyAfterHash
};

var fromUrl$1 = (giturl, opts, { gitHosts, protocols }) => {
  if (!giturl) {
    return
  }

  const correctedUrl = isGitHubShorthand(giturl) ? `github:${giturl}` : giturl;
  const parsed = parseUrl$1(correctedUrl, protocols);
  if (!parsed) {
    return
  }

  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.')
    ? parsed.hostname.slice(4)
    : parsed.hostname];
  const gitHostName = gitHostShortcut || gitHostDomain;
  if (!gitHostName) {
    return
  }

  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
  let auth = null;
  if (protocols[parsed.protocol]?.auth && (parsed.username || parsed.password)) {
    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;
  }

  let committish = null;
  let user = null;
  let project = null;
  let defaultRepresentation = null;

  try {
    if (gitHostShortcut) {
      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;
      const firstAt = pathname.indexOf('@');
      // we ignore auth for shortcuts, so just trim it out
      if (firstAt > -1) {
        pathname = pathname.slice(firstAt + 1);
      }

      const lastSlash = pathname.lastIndexOf('/');
      if (lastSlash > -1) {
        user = decodeURIComponent(pathname.slice(0, lastSlash));
        // we want nulls only, never empty strings
        if (!user) {
          user = null;
        }
        project = decodeURIComponent(pathname.slice(lastSlash + 1));
      } else {
        project = decodeURIComponent(pathname);
      }

      if (project.endsWith('.git')) {
        project = project.slice(0, -4);
      }

      if (parsed.hash) {
        committish = decodeURIComponent(parsed.hash.slice(1));
      }

      defaultRepresentation = 'shortcut';
    } else {
      if (!gitHostInfo.protocols.includes(parsed.protocol)) {
        return
      }

      const segments = gitHostInfo.extract(parsed);
      if (!segments) {
        return
      }

      user = segments.user && decodeURIComponent(segments.user);
      project = decodeURIComponent(segments.project);
      committish = decodeURIComponent(segments.committish);
      defaultRepresentation = protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
    }
  } catch (err) {
    /* istanbul ignore else */
    if (err instanceof URIError) {
      return
    } else {
      throw err
    }
  }

  return [gitHostName, user, auth, project, committish, defaultRepresentation, opts]
};

const { LRUCache } = commonjs;
const hosts = hosts_1;
const fromUrl = fromUrl$1;
const parseUrl = parseUrl$2;

const cache = new LRUCache({ max: 1000 });

class GitHost {
  constructor (type, user, auth, project, committish, defaultRepresentation, opts = {}) {
    Object.assign(this, GitHost.#gitHosts[type], {
      type,
      user,
      auth,
      project,
      committish,
      default: defaultRepresentation,
      opts,
    });
  }

  static #gitHosts = { byShortcut: {}, byDomain: {} }
  static #protocols = {
    'git+ssh:': { name: 'sshurl' },
    'ssh:': { name: 'sshurl' },
    'git+https:': { name: 'https', auth: true },
    'git:': { auth: true },
    'http:': { auth: true },
    'https:': { auth: true },
    'git+http:': { auth: true },
  }

  static addHost (name, host) {
    GitHost.#gitHosts[name] = host;
    GitHost.#gitHosts.byDomain[host.domain] = name;
    GitHost.#gitHosts.byShortcut[`${name}:`] = name;
    GitHost.#protocols[`${name}:`] = { name };
  }

  static fromUrl (giturl, opts) {
    if (typeof giturl !== 'string') {
      return
    }

    const key = giturl + JSON.stringify(opts || {});

    if (!cache.has(key)) {
      const hostArgs = fromUrl(giturl, opts, {
        gitHosts: GitHost.#gitHosts,
        protocols: GitHost.#protocols,
      });
      cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined);
    }

    return cache.get(key)
  }

  static parseUrl (url) {
    return parseUrl(url)
  }

  #fill (template, opts) {
    if (typeof template !== 'function') {
      return null
    }

    const options = { ...this, ...this.opts, ...opts };

    // the path should always be set so we don't end up with 'undefined' in urls
    if (!options.path) {
      options.path = '';
    }

    // template functions will insert the leading slash themselves
    if (options.path.startsWith('/')) {
      options.path = options.path.slice(1);
    }

    if (options.noCommittish) {
      options.committish = null;
    }

    const result = template(options);
    return options.noGitPlus && result.startsWith('git+') ? result.slice(4) : result
  }

  hash () {
    return this.committish ? `#${this.committish}` : ''
  }

  ssh (opts) {
    return this.#fill(this.sshtemplate, opts)
  }

  sshurl (opts) {
    return this.#fill(this.sshurltemplate, opts)
  }

  browse (path, ...args) {
    // not a string, treat path as opts
    if (typeof path !== 'string') {
      return this.#fill(this.browsetemplate, path)
    }

    if (typeof args[0] !== 'string') {
      return this.#fill(this.browsetreetemplate, { ...args[0], path })
    }

    return this.#fill(this.browsetreetemplate, { ...args[1], fragment: args[0], path })
  }

  // If the path is known to be a file, then browseFile should be used. For some hosts
  // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
  // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
  // path will redirect to a specific commit. Using the `/blob/` path avoids this and
  // does not redirect to a different commit.
  browseFile (path, ...args) {
    if (typeof args[0] !== 'string') {
      return this.#fill(this.browseblobtemplate, { ...args[0], path })
    }

    return this.#fill(this.browseblobtemplate, { ...args[1], fragment: args[0], path })
  }

  docs (opts) {
    return this.#fill(this.docstemplate, opts)
  }

  bugs (opts) {
    return this.#fill(this.bugstemplate, opts)
  }

  https (opts) {
    return this.#fill(this.httpstemplate, opts)
  }

  git (opts) {
    return this.#fill(this.gittemplate, opts)
  }

  shortcut (opts) {
    return this.#fill(this.shortcuttemplate, opts)
  }

  path (opts) {
    return this.#fill(this.pathtemplate, opts)
  }

  tarball (opts) {
    return this.#fill(this.tarballtemplate, { ...opts, noCommittish: false })
  }

  file (path, opts) {
    return this.#fill(this.filetemplate, { ...opts, path })
  }

  edit (path, opts) {
    return this.#fill(this.edittemplate, { ...opts, path })
  }

  getDefaultRepresentation () {
    return this.default
  }

  toString (opts) {
    if (this.default && typeof this[this.default] === 'function') {
      return this[this.default](opts)
    }

    return this.sshurl(opts)
  }
}

for (const [name, host] of Object.entries(hosts)) {
  GitHost.addHost(name, host);
}

var lib$2 = GitHost;

const semver$1 = semver$2;

const permanentModules = [
  'assert',
  'buffer',
  'child_process',
  'cluster',
  'console',
  'constants',
  'crypto',
  'dgram',
  'dns',
  'domain',
  'events',
  'fs',
  'http',
  'https',
  'module',
  'net',
  'os',
  'path',
  'punycode',
  'querystring',
  'readline',
  'repl',
  'stream',
  'string_decoder',
  'sys',
  'timers',
  'tls',
  'tty',
  'url',
  'util',
  'vm',
  'zlib'
];

const versionLockedModules = {
  freelist: '<6.0.0',
  v8: '>=1.0.0',
  process: '>=1.1.0',
  inspector: '>=8.0.0',
  async_hooks: '>=8.1.0',
  http2: '>=8.4.0',
  perf_hooks: '>=8.5.0',
  trace_events: '>=10.0.0',
  worker_threads: '>=12.0.0',
  'node:test': '>=18.0.0'
};

const experimentalModules = {
  worker_threads: '>=10.5.0',
  wasi: '>=12.16.0',
  diagnostics_channel: '^14.17.0 || >=15.1.0'
};

var builtins$1 = ({ version = process.version, experimental = false } = {}) => {
  const builtins = [...permanentModules];

  for (const [name, semverRange] of Object.entries(versionLockedModules)) {
    if (version === '*' || semver$1.satisfies(version, semverRange)) {
      builtins.push(name);
    }
  }

  if (experimental) {
    for (const [name, semverRange] of Object.entries(experimentalModules)) {
      if (
        !builtins.includes(name) &&
        (version === '*' || semver$1.satisfies(version, semverRange))
      ) {
        builtins.push(name);
      }
    }
  }

  return builtins
};

var scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$');
var builtins = builtins$1;
var blacklist = [
  'node_modules',
  'favicon.ico',
];

function validate (name) {
  var warnings = [];
  var errors = [];

  if (name === null) {
    errors.push('name cannot be null');
    return done(warnings, errors)
  }

  if (name === undefined) {
    errors.push('name cannot be undefined');
    return done(warnings, errors)
  }

  if (typeof name !== 'string') {
    errors.push('name must be a string');
    return done(warnings, errors)
  }

  if (!name.length) {
    errors.push('name length must be greater than zero');
  }

  if (name.match(/^\./)) {
    errors.push('name cannot start with a period');
  }

  if (name.match(/^_/)) {
    errors.push('name cannot start with an underscore');
  }

  if (name.trim() !== name) {
    errors.push('name cannot contain leading or trailing spaces');
  }

  // No funny business
  blacklist.forEach(function (blacklistedName) {
    if (name.toLowerCase() === blacklistedName) {
      errors.push(blacklistedName + ' is a blacklisted name');
    }
  });

  // Generate warnings for stuff that used to be allowed

  // core module names like http, events, util, etc
  builtins({ version: '*' }).forEach(function (builtin) {
    if (name.toLowerCase() === builtin) {
      warnings.push(builtin + ' is a core module name');
    }
  });

  if (name.length > 214) {
    warnings.push('name can no longer contain more than 214 characters');
  }

  // mIxeD CaSe nAMEs
  if (name.toLowerCase() !== name) {
    warnings.push('name can no longer contain capital letters');
  }

  if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
    warnings.push('name can no longer contain special characters ("~\'!()*")');
  }

  if (encodeURIComponent(name) !== name) {
    // Maybe it's a scoped package name, like @user/package
    var nameMatch = name.match(scopedPackagePattern);
    if (nameMatch) {
      var user = nameMatch[1];
      var pkg = nameMatch[2];
      if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
        return done(warnings, errors)
      }
    }

    errors.push('name can only contain URL-friendly characters');
  }

  return done(warnings, errors)
}

var done = function (warnings, errors) {
  var result = {
    validForNewPackages: errors.length === 0 && warnings.length === 0,
    validForOldPackages: errors.length === 0,
    warnings: warnings,
    errors: errors,
  };
  if (!result.warnings.length) {
    delete result.warnings;
  }
  if (!result.errors.length) {
    delete result.errors;
  }
  return result
};

var lib$1 = validate;

var lib = {
  output: {
    LEVELS: [
      'standard',
      'error',
      'buffer',
    ],
    standard: function (...args) {
      return process.emit('output', 'standard', ...args)
    },
    error: function (...args) {
      return process.emit('output', 'error', ...args)
    },
    buffer: function (...args) {
      return process.emit('output', 'buffer', ...args)
    },
  },
  log: {
    LEVELS: [
      'notice',
      'error',
      'warn',
      'info',
      'verbose',
      'http',
      'silly',
      'timing',
      'pause',
      'resume',
    ],
    error: function (...args) {
      return process.emit('log', 'error', ...args)
    },
    notice: function (...args) {
      return process.emit('log', 'notice', ...args)
    },
    warn: function (...args) {
      return process.emit('log', 'warn', ...args)
    },
    info: function (...args) {
      return process.emit('log', 'info', ...args)
    },
    verbose: function (...args) {
      return process.emit('log', 'verbose', ...args)
    },
    http: function (...args) {
      return process.emit('log', 'http', ...args)
    },
    silly: function (...args) {
      return process.emit('log', 'silly', ...args)
    },
    timing: function (...args) {
      return process.emit('log', 'timing', ...args)
    },
    pause: function (...args) {
      return process.emit('log', 'pause', ...args)
    },
    resume: function (...args) {
      return process.emit('log', 'resume', ...args)
    },
  },
};

npa$3.exports = npa;
npa$3.exports.resolve = resolve;
npa$3.exports.toPurl = toPurl;
npa$3.exports.Result = Result;

const { URL } = require$$0;
const HostedGit = lib$2;
const semver = semver$2;
const path = commonjsGlobal.FAKE_WINDOWS ? require$$0$1.win32 : require$$0$1;
const validatePackageName = lib$1;
const { homedir } = require$$0$2;
const { log } = lib;

const isWindows = process.platform === 'win32' || commonjsGlobal.FAKE_WINDOWS;
const hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
const isURL = /^(?:git[+])?[a-z]+:/i;
const isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i;
const isFilename = /[.](?:tgz|tar.gz|tar)$/i;

function npa (arg, where) {
  let name;
  let spec;
  if (typeof arg === 'object') {
    if (arg instanceof Result && (!where || where === arg.where)) {
      return arg
    } else if (arg.name && arg.rawSpec) {
      return npa.resolve(arg.name, arg.rawSpec, where || arg.where)
    } else {
      return npa(arg.raw, where || arg.where)
    }
  }
  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');
  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
  if (isURL.test(arg)) {
    spec = arg;
  } else if (isGit.test(arg)) {
    spec = `git+ssh://${arg}`;
  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {
    spec = arg;
  } else if (nameEndsAt > 0) {
    name = namePart;
    spec = arg.slice(nameEndsAt + 1) || '*';
  } else {
    const valid = validatePackageName(arg);
    if (valid.validForOldPackages) {
      name = arg;
      spec = '*';
    } else {
      spec = arg;
    }
  }
  return resolve(name, spec, where, arg)
}

const isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;

function resolve (name, spec, where, arg) {
  const res = new Result({
    raw: arg,
    name: name,
    rawSpec: spec,
    fromArgument: arg != null,
  });

  if (name) {
    res.setName(name);
  }

  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {
    return fromFile(res, where)
  } else if (spec && /^npm:/i.test(spec)) {
    return fromAlias(res, where)
  }

  const hosted = HostedGit.fromUrl(spec, {
    noGitPlus: true,
    noCommittish: true,
  });
  if (hosted) {
    return fromHostedGit(res, hosted)
  } else if (spec && isURL.test(spec)) {
    return fromURL(res)
  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {
    return fromFile(res, where)
  } else {
    return fromRegistry(res)
  }
}

const defaultRegistry = 'https://registry.npmjs.org';

function toPurl (arg, reg = defaultRegistry) {
  const res = npa(arg);

  if (res.type !== 'version') {
    throw invalidPurlType(res.type, res.raw)
  }

  // URI-encode leading @ of scoped packages
  let purl = 'pkg:npm/' + res.name.replace(/^@/, '%40') + '@' + res.rawSpec;
  if (reg !== defaultRegistry) {
    purl += '?repository_url=' + reg;
  }

  return purl
}

function invalidPackageName (name, valid, raw) {
  // eslint-disable-next-line max-len
  const err = new Error(`Invalid package name "${name}" of package "${raw}": ${valid.errors.join('; ')}.`);
  err.code = 'EINVALIDPACKAGENAME';
  return err
}

function invalidTagName (name, raw) {
  // eslint-disable-next-line max-len
  const err = new Error(`Invalid tag name "${name}" of package "${raw}": Tags may not have any characters that encodeURIComponent encodes.`);
  err.code = 'EINVALIDTAGNAME';
  return err
}

function invalidPurlType (type, raw) {
  // eslint-disable-next-line max-len
  const err = new Error(`Invalid type "${type}" of package "${raw}": Purl can only be generated for "version" types.`);
  err.code = 'EINVALIDPURLTYPE';
  return err
}

function Result (opts) {
  this.type = opts.type;
  this.registry = opts.registry;
  this.where = opts.where;
  if (opts.raw == null) {
    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;
  } else {
    this.raw = opts.raw;
  }

  this.name = undefined;
  this.escapedName = undefined;
  this.scope = undefined;
  this.rawSpec = opts.rawSpec || '';
  this.saveSpec = opts.saveSpec;
  this.fetchSpec = opts.fetchSpec;
  if (opts.name) {
    this.setName(opts.name);
  }
  this.gitRange = opts.gitRange;
  this.gitCommittish = opts.gitCommittish;
  this.gitSubdir = opts.gitSubdir;
  this.hosted = opts.hosted;
}

Result.prototype.setName = function (name) {
  const valid = validatePackageName(name);
  if (!valid.validForOldPackages) {
    throw invalidPackageName(name, valid, this.raw)
  }

  this.name = name;
  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined;
  // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar
  this.escapedName = name.replace('/', '%2f');
  return this
};

Result.prototype.toString = function () {
  const full = [];
  if (this.name != null && this.name !== '') {
    full.push(this.name);
  }
  const spec = this.saveSpec || this.fetchSpec || this.rawSpec;
  if (spec != null && spec !== '') {
    full.push(spec);
  }
  return full.length ? full.join('@') : this.raw
};

Result.prototype.toJSON = function () {
  const result = Object.assign({}, this);
  delete result.hosted;
  return result
};

// sets res.gitCommittish, res.gitRange, and res.gitSubdir
function setGitAttrs (res, committish) {
  if (!committish) {
    res.gitCommittish = null;
    return
  }

  // for each :: separated item:
  for (const part of committish.split('::')) {
    // if the item has no : the n it is a commit-ish
    if (!part.includes(':')) {
      if (res.gitRange) {
        throw new Error('cannot override existing semver range with a committish')
      }
      if (res.gitCommittish) {
        throw new Error('cannot override existing committish with a second committish')
      }
      res.gitCommittish = part;
      continue
    }
    // split on name:value
    const [name, value] = part.split(':');
    // if name is semver do semver lookup of ref or tag
    if (name === 'semver') {
      if (res.gitCommittish) {
        throw new Error('cannot override existing committish with a semver range')
      }
      if (res.gitRange) {
        throw new Error('cannot override existing semver range with a second semver range')
      }
      res.gitRange = decodeURIComponent(value);
      continue
    }
    if (name === 'path') {
      if (res.gitSubdir) {
        throw new Error('cannot override existing path with a second path')
      }
      res.gitSubdir = `/${value}`;
      continue
    }
    log.warn('npm-package-arg', `ignoring unknown key "${name}"`);
  }
}

function fromFile (res, where) {
  if (!where) {
    where = process.cwd();
  }
  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';
  res.where = where;

  // always put the '/' on where when resolving urls, or else
  // file:foo from /path/to/bar goes to /path/to/foo, when we want
  // it to be /path/to/bar/foo

  let specUrl;
  let resolvedUrl;
  const prefix = (!/^file:/.test(res.rawSpec) ? 'file:' : '');
  const rawWithPrefix = prefix + res.rawSpec;
  let rawNoPrefix = rawWithPrefix.replace(/^file:/, '');
  try {
    resolvedUrl = new URL(rawWithPrefix, `file://${path.resolve(where)}/`);
    specUrl = new URL(rawWithPrefix);
  } catch (originalError) {
    const er = new Error('Invalid file: URL, must comply with RFC 8089');
    throw Object.assign(er, {
      raw: res.rawSpec,
      spec: res,
      where,
      originalError,
    })
  }

  // XXX backwards compatibility lack of compliance with RFC 8089
  if (resolvedUrl.host && resolvedUrl.host !== 'localhost') {
    const rawSpec = res.rawSpec.replace(/^file:\/\//, 'file:///');
    resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`);
    specUrl = new URL(rawSpec);
    rawNoPrefix = rawSpec.replace(/^file:/, '');
  }
  // turn file:/../foo into file:../foo
  // for 1, 2 or 3 leading slashes since we attempted
  // in the previous step to make it a file protocol url with a leading slash
  if (/^\/{1,3}\.\.?(\/|$)/.test(rawNoPrefix)) {
    const rawSpec = res.rawSpec.replace(/^file:\/{1,3}/, 'file:');
    resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`);
    specUrl = new URL(rawSpec);
    rawNoPrefix = rawSpec.replace(/^file:/, '');
  }
  // XXX end RFC 8089 violation backwards compatibility section

  // turn /C:/blah into just C:/blah on windows
  let specPath = decodeURIComponent(specUrl.pathname);
  let resolvedPath = decodeURIComponent(resolvedUrl.pathname);
  if (isWindows) {
    specPath = specPath.replace(/^\/+([a-z]:\/)/i, '$1');
    resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, '$1');
  }

  // replace ~ with homedir, but keep the ~ in the saveSpec
  // otherwise, make it relative to where param
  if (/^\/~(\/|$)/.test(specPath)) {
    res.saveSpec = `file:${specPath.substr(1)}`;
    resolvedPath = path.resolve(homedir(), specPath.substr(3));
  } else if (!path.isAbsolute(rawNoPrefix)) {
    res.saveSpec = `file:${path.relative(where, resolvedPath)}`;
  } else {
    res.saveSpec = `file:${path.resolve(resolvedPath)}`;
  }

  res.fetchSpec = path.resolve(where, resolvedPath);
  return res
}

function fromHostedGit (res, hosted) {
  res.type = 'git';
  res.hosted = hosted;
  res.saveSpec = hosted.toString({ noGitPlus: false, noCommittish: false });
  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();
  setGitAttrs(res, hosted.committish);
  return res
}

function unsupportedURLType (protocol, spec) {
  const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
  err.code = 'EUNSUPPORTEDPROTOCOL';
  return err
}

function fromURL (res) {
  let rawSpec = res.rawSpec;
  res.saveSpec = rawSpec;
  if (rawSpec.startsWith('git+ssh:')) {
    // git ssh specifiers are overloaded to also use scp-style git
    // specifiers, so we have to parse those out and treat them special.
    // They are NOT true URIs, so we can't hand them to URL.

    // This regex looks for things that look like:
    // git+ssh://git@my.custom.git.com:username/project.git#deadbeef
    // ...and various combinations. The username in the beginning is *required*.
    const matched = rawSpec.match(/^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i);
    if (matched && !matched[1].match(/:[0-9]+\/?.*$/i)) {
      res.type = 'git';
      setGitAttrs(res, matched[2]);
      res.fetchSpec = matched[1];
      return res
    }
  } else if (rawSpec.startsWith('git+file://')) {
    // URL can't handle windows paths
    rawSpec = rawSpec.replace(/\\/g, '/');
  }
  const parsedUrl = new URL(rawSpec);
  // check the protocol, and then see if it's git or not
  switch (parsedUrl.protocol) {
    case 'git:':
    case 'git+http:':
    case 'git+https:':
    case 'git+rsync:':
    case 'git+ftp:':
    case 'git+file:':
    case 'git+ssh:':
      res.type = 'git';
      setGitAttrs(res, parsedUrl.hash.slice(1));
      if (parsedUrl.protocol === 'git+file:' && /^git\+file:\/\/[a-z]:/i.test(rawSpec)) {
        // URL can't handle drive letters on windows file paths, the host can't contain a :
        res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`;
      } else {
        parsedUrl.hash = '';
        res.fetchSpec = parsedUrl.toString();
      }
      if (res.fetchSpec.startsWith('git+')) {
        res.fetchSpec = res.fetchSpec.slice(4);
      }
      break
    case 'http:':
    case 'https:':
      res.type = 'remote';
      res.fetchSpec = res.saveSpec;
      break

    default:
      throw unsupportedURLType(parsedUrl.protocol, rawSpec)
  }

  return res
}

function fromAlias (res, where) {
  const subSpec = npa(res.rawSpec.substr(4), where);
  if (subSpec.type === 'alias') {
    throw new Error('nested aliases not supported')
  }

  if (!subSpec.registry) {
    throw new Error('aliases only work for registry deps')
  }

  res.subSpec = subSpec;
  res.registry = true;
  res.type = 'alias';
  res.saveSpec = null;
  res.fetchSpec = null;
  return res
}

function fromRegistry (res) {
  res.registry = true;
  const spec = res.rawSpec.trim();
  // no save spec for registry components as we save based on the fetched
  // version, not on the argument so this can't compute that.
  res.saveSpec = null;
  res.fetchSpec = spec;
  const version = semver.valid(spec, true);
  const range = semver.validRange(spec, true);
  if (version) {
    res.type = 'version';
  } else if (range) {
    res.type = 'range';
  } else {
    if (encodeURIComponent(spec) !== spec) {
      throw invalidTagName(spec, res.raw)
    }
    res.type = 'tag';
  }
  return res
}

var npaExports = npa$3.exports;
const npa$1 = /*@__PURE__*/getDefaultExportFromCjs(npaExports);

const npa$2 = {
  __proto__: null,
  default: npa$1
};

export { npaExports as a, lib as l, npa$2 as n };
