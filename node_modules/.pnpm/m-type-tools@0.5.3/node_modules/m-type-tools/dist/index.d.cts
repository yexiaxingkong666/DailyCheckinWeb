type AnyFunction = (...args: any) => any;
type AsyncFunciton<T extends AnyFunction> = (...args: Parameters<T>) => Awaited<ReturnType<T>>;
type AnyAsyncFunction = AsyncFunciton<AnyFunction>;

declare const isSymobl: (v: unknown) => v is symbol;
declare const isString: (v: unknown) => v is string;
declare const isNumber: (v: unknown) => v is number;
declare const isBoolean: (v: unknown) => v is boolean;
declare const isArray: (v: unknown) => v is any[];
declare const isFunction: (v: unknown) => v is Function;
declare const isObject: (v: unknown) => v is object;
declare const isAsyncFunciton: (v: unknown) => v is AnyAsyncFunction;
declare const isSet: (v: unknown) => v is Set<any>;
declare const isWeakSet: (v: unknown) => v is WeakSet<any>;
declare const isMap: (v: unknown) => v is Map<any, any>;
declare const isWeakMap: (v: unknown) => v is WeakMap<any, any>;
declare const isPromise: (v: unknown) => v is Promise<any>;
declare const isUndefined: (v: undefined) => v is undefined;

type UnArray<T> = T extends Array<infer P> ? P : T;
type UnSet<T> = T extends Set<infer P> ? P : T;
type UnWeakSet<T> = T extends WeakSet<infer P> ? P : T;
type UnMap<T> = T extends Map<infer K, infer V> ? [K, V] : T;
type UnWeakMap<T> = T extends WeakMap<infer K, infer V> ? [K, V] : T;
type UnPromise<T> = T extends Promise<infer P> ? P : T;
type UnPromiseReturnType<T extends AnyFunction> = UnPromise<ReturnType<T>>;
type UnAsyncFunctionReturnType<T extends AnyAsyncFunction> = UnPromise<ReturnType<T>>;

type PartialPick<T, K extends keyof T> = Partial<Pick<T, K>>;
type RequiredPick<T, K extends keyof T> = Required<Pick<T, K>>;
type ReadonlyPick<T, K extends keyof T> = Readonly<Pick<T, K>>;

type Arrayable<T> = T | Array<T>;
type ItemExist<V, A = []> = A extends [
    infer F,
    ...infer P
] ? V extends F ? V : ItemExist<V, P> : never;
type ItemNotExist<V, A = []> = A extends [
    infer F,
    ...infer P
] ? V extends F ? never : ItemNotExist<V, P> : V;
type FilterNeverInArray<T, G extends unknown[] = []> = T extends [infer F, ...infer P] ? FilterNeverInArray<P, [
    F
] extends [never] ? [...G] : [...G, F]> : G;
type UniqueArray<T, G extends unknown[] = []> = T extends [...infer P, infer L] ? UniqueArray<P, [ItemNotExist<L, P>, ...G]> : FilterNeverInArray<G>;

type PickUnion<U, K> = U extends K ? U : never;
type OmitUnion<U, K> = U extends PickUnion<U, K> ? never : U;
type UnionToIntersection<T> = (T extends any ? (args: T) => any : never) extends (args: infer R) => any ? R : never;
type LastInUnion<T> = UnionToIntersection<T extends any ? (arg: T) => any : never> extends (arg: infer R) => any ? R : never;
type UnionToTuple<T, U = T> = [T] extends [never] ? [] : [
    ...UnionToTuple<Exclude<U, LastInUnion<T>>>,
    LastInUnion<T>
];

type MayBeArray<T> = T | Array<T>;
type MayBePromise<T> = T | Promise<T>;

export { type AnyAsyncFunction, type AnyFunction, type Arrayable, type AsyncFunciton, type FilterNeverInArray, type ItemExist, type ItemNotExist, type LastInUnion, type MayBeArray, type MayBePromise, type OmitUnion, type PartialPick, type PickUnion, type ReadonlyPick, type RequiredPick, type UnArray, type UnAsyncFunctionReturnType, type UnMap, type UnPromise, type UnPromiseReturnType, type UnSet, type UnWeakMap, type UnWeakSet, type UnionToIntersection, type UnionToTuple, type UniqueArray, isArray, isAsyncFunciton, isBoolean, isFunction, isMap, isNumber, isObject, isPromise, isSet, isString, isSymobl, isUndefined, isWeakMap, isWeakSet };
